<?xml version="1.0" encoding="UTF-8"?>
<p:declare-step xmlns:p="http://www.w3.org/ns/xproc" version="1.0"
                xmlns:px="http://www.daisy.org/ns/pipeline/xproc"
                xmlns:c="http://www.w3.org/ns/xproc-step"
                xmlns:d="http://www.daisy.org/ns/pipeline/data"
                xmlns:css="http://www.daisy.org/ns/pipeline/braille-css"
                xmlns:ocf="urn:oasis:names:tc:opendocument:xmlns:container"
                xmlns:html="http://www.w3.org/1999/xhtml"
                xmlns:epub="http://www.idpf.org/2007/ops"
                xmlns:opf="http://www.idpf.org/2007/opf"
                xmlns:dc="http://purl.org/dc/elements/1.1/"
                xmlns:rendition="http://www.idpf.org/2013/rendition"
                exclude-inline-prefixes="#all"
                type="px:epub3-to-epub3"
                name="main">
    
    <p:input port="epub.in.fileset" primary="true"/>
    <p:input port="epub.in.in-memory" sequence="true"/>
    
    <p:output port="epub.out.fileset" primary="true"/>
    <p:output port="epub.out.in-memory" sequence="true">
        <p:pipe step="add-braille-rendition" port="in-memory"/>
    </p:output>
    
    <p:input port="metadata" sequence="true">
        <p:empty/>
    </p:input>
    
    <p:option name="result-base" required="false">
        <p:documentation xmlns="http://www.w3.org/1999/xhtml">
            <p>If not specified, will not copy EPUB before modifying it.</p>
        </p:documentation>
    </p:option>
    <p:option name="update-lang-attributes" required="false" select="'false'"/>
    <p:option name="update-identifier-in-content-docs" required="false" select="'false'"/>
    <p:option name="update-title-in-content-docs" required="false" select="'false'"/>
    <p:option name="ensure-pagenum-text" required="false" select="'false'"/>
    <p:option name="ensure-section-headings" required="false" select="'false'"/>
    <p:option name="braille" required="false" select="'false'"/>
    <p:option name="tts" required="false" select="'default'"/>
    <p:option name="sentence-detection" required="false" select="'false'"/>
    <p:option name="braille-translator" select="''"/>
    <p:option name="stylesheet" select="''"/>
    <p:option name="apply-document-specific-stylesheets" select="'false'"/>
    <p:option name="set-default-rendition-to-braille" select="'false'"/>
    <p:option name="content-media-types" select="'application/xhtml+xml'">
        <!--
            space separated list of content document media-types to include in the braille rendition
        -->
    </p:option>
    <p:input port="tts-config">
        <p:inline><d:config/></p:inline>
    </p:input>
    <p:option name="sentence-class" required="false" select="''"/>
    <p:output port="temp-audio-files">
        <p:documentation>
            List of audio files generated by the TTS step. May be deleted when the result fileset is
            stored.
        </p:documentation>
        <p:pipe step="add-mediaoverlays" port="temp-audio.fileset"/>
    </p:output>
    <p:option name="include-tts-log" select="'false'">
        <p:documentation xmlns="http://www.w3.org/1999/xhtml">
            <p>Whether or not to make the TTS log available on the "tts-log" port.</p>
            <p>Note that if this option is set to false, it can still be overwritten by the
            "org.daisy.pipeline.tts.log" property.</p>
        </p:documentation>
    </p:option>
    <p:output port="tts-log" sequence="true">
        <p:pipe step="add-mediaoverlays" port="log"/>
    </p:output>
    <p:option name="temp-dir" required="false" select="''">
        <p:documentation xmlns="http://www.w3.org/1999/xhtml">
            <p>Empty directory dedicated to this step. If set, the directory will be used to store
            audio files. If not set, the audio files will be stored in temporary directory that is
            automatically created.</p>
        </p:documentation>
    </p:option>
    
    <p:import href="http://www.daisy.org/pipeline/modules/common-utils/library.xpl">
        <p:documentation>
            px:error
            px:message
        </p:documentation>
    </p:import>
    <p:import href="http://www.daisy.org/pipeline/modules/file-utils/library.xpl">
        <p:documentation>
            px:set-base-uri
        </p:documentation>
    </p:import>
    <p:import href="http://www.daisy.org/pipeline/modules/fileset-utils/library.xpl">
        <p:documentation>
            px:fileset-create
            px:fileset-add-entry
            px:fileset-join
            px:fileset-rebase
            px:fileset-copy
            px:fileset-load
            px:fileset-filter
            px:fileset-update
        </p:documentation>
    </p:import>
    <p:import href="http://www.daisy.org/pipeline/modules/html-utils/library.xpl">
        <p:documentation>
            px:html-outline
        </p:documentation>
    </p:import>
    <p:import href="http://www.daisy.org/pipeline/modules/epub-utils/library.xpl">
        <p:documentation>
            px:epub-update-links
            px:epub3-create-mediaoverlays
            px:epub3-add-mediaoverlays
            px:epub3-add-metadata
            px:epub3-label-pagebreaks-from-nav
            px:opf-spine-to-fileset
        </p:documentation>
    </p:import>
    <p:import href="http://www.daisy.org/pipeline/modules/braille/common-utils/library.xpl">
        <p:documentation>
            px:transform
            px:apply-stylesheets
        </p:documentation>
    </p:import>
    <p:import href="http://www.daisy.org/pipeline/modules/braille/css-utils/library.xpl">
        <p:documentation>
            css:delete-stylesheets
            css:extract
        </p:documentation>
    </p:import>
    <p:import href="http://www.daisy.org/pipeline/modules/epub3-tts/library.xpl">
        <p:documentation>
            px:tts-for-epub3
        </p:documentation>
    </p:import>
    <p:import href="http://www.daisy.org/pipeline/modules/html-break-detection/library.xpl">
        <p:documentation>
            px:html-break-detect
            px:html-unwrap-words
        </p:documentation>
    </p:import>
    <p:import href="http://www.daisy.org/pipeline/modules/tts-common/library.xpl">
        <p:documentation>
            px:isolate-skippable
        </p:documentation>
    </p:import>
    
    <p:variable name="default-stylesheet" select="resolve-uri('../css/default.css')">
        <p:inline>
            <irrelevant/>
        </p:inline>
    </p:variable>
    
    <p:identity>
        <p:input port="source">
            <p:pipe step="main" port="epub.in.fileset"/>
        </p:input>
    </p:identity>
    
    <!--
        Make sure that the base uri of the fileset is the directory containing the mimetype
        file. This will normally also eliminate any relative hrefs starting with "..", which is
        needed because px:fileset-copy errors when it encounters these.
    -->
    <p:choose>
        <p:when test="//d:file[matches(@href,'^(.+/)?mimetype$')]">
            <px:fileset-rebase>
                <p:with-option name="new-base"
                               select="//d:file[matches(@href,'^(.+/)?mimetype$')][1]
                                       /replace(resolve-uri(@href,base-uri(.)),'mimetype$','')"/>
            </px:fileset-rebase>
        </p:when>
        <p:otherwise>
            <px:error code="XXXXX" message="Fileset must contain a 'mimetype' file"/>
        </p:otherwise>
    </p:choose>
    
    <!--
        copy EPUB to new location
    -->
    <p:choose name="maybe-copy">
        <p:when test="p:value-available('result-base')">
            <p:output port="fileset" primary="true"/>
            <p:output port="in-memory" sequence="true">
                <p:pipe step="copy" port="result.in-memory"/>
            </p:output>
            <px:fileset-copy name="copy">
                <p:with-option name="target" select="$result-base"/>
                <p:input port="source.in-memory">
                    <p:pipe step="main" port="epub.in.in-memory"/>
                </p:input>
            </px:fileset-copy>
        </p:when>
        <p:otherwise>
            <p:output port="fileset" primary="true"/>
            <p:output port="in-memory" sequence="true">
                <p:pipe step="main" port="epub.in.in-memory"/>
            </p:output>
            <p:identity/>
        </p:otherwise>
    </p:choose>
    
    <!--
        Add metadata
    -->
    <p:sink/>
    <p:count>
        <p:input port="source">
            <p:pipe step="main" port="metadata"/>
        </p:input>
    </p:count>
    <p:choose name="add-metadata">
        <p:when test="/*=0">
            <p:output port="fileset" primary="true"/>
            <p:output port="in-memory" sequence="true">
                <p:pipe step="maybe-copy" port="in-memory"/>
            </p:output>
            <p:sink/>
            <p:identity>
                <p:input port="source">
                    <p:pipe step="maybe-copy" port="fileset"/>
                </p:input>
            </p:identity>
        </p:when>
        <p:otherwise>
            <p:output port="fileset" primary="true"/>
            <p:output port="in-memory" sequence="true">
                <p:pipe step="add" port="result.in-memory"/>
            </p:output>
            <p:sink/>
            <px:epub3-add-metadata name="add">
                <p:input port="source.fileset">
                    <p:pipe step="maybe-copy" port="fileset"/>
                </p:input>
                <p:input port="source.in-memory">
                    <p:pipe step="maybe-copy" port="in-memory"/>
                </p:input>
                <p:input port="metadata">
                    <p:pipe step="main" port="metadata"/>
                </p:input>
            </px:epub3-add-metadata>
        </p:otherwise>
    </p:choose>
    
    <!--
        Update metadata in content documents and lang attributes in package and content documents
    -->
    <p:choose name="update-lang-attributes-and-html-meta">
        <p:when test="'true'=($update-lang-attributes,
                              $update-identifier-in-content-docs,
                              $update-title-in-content-docs)">
            <p:output port="fileset" primary="true"/>
            <p:output port="in-memory" sequence="true">
                <p:pipe step="update-html" port="in-memory"/>
            </p:output>
            <px:fileset-load media-types="application/oebps-package+xml" name="package-doc">
                <p:input port="in-memory">
                    <p:pipe step="add-metadata" port="in-memory"/>
                </p:input>
            </px:fileset-load>
            <p:choose name="update-package-doc">
                <!-- only do something when there is exactly one dc:language -->
                <p:when test="($update-lang-attributes='true' and count(/*/opf:metadata/dc:language)=1)">
                    <p:output port="fileset" primary="true"/>
                    <p:output port="in-memory" sequence="true">
                        <p:pipe step="update" port="result.in-memory"/>
                    </p:output>
                    <p:add-attribute match="/*" attribute-name="xml:lang" name="package-doc-with-new-lang">
                        <p:with-option name="attribute-value" select="/*/opf:metadata/dc:language/string(.)"/>
                    </p:add-attribute>
                    <p:sink/>
                    <px:fileset-update name="update">
                        <p:input port="source.fileset">
                            <p:pipe step="add-metadata" port="fileset"/>
                        </p:input>
                        <p:input port="source.in-memory">
                            <p:pipe step="add-metadata" port="in-memory"/>
                        </p:input>
                        <p:input port="update.fileset">
                            <p:pipe step="package-doc" port="result.fileset"/>
                        </p:input>
                        <p:input port="update.in-memory">
                            <p:pipe step="package-doc-with-new-lang" port="result"/>
                        </p:input>
                    </px:fileset-update>
                </p:when>
                <p:otherwise>
                    <p:output port="fileset" primary="true"/>
                    <p:output port="in-memory" sequence="true">
                        <p:pipe step="add-metadata" port="in-memory"/>
                    </p:output>
                    <p:sink/>
                    <p:identity>
                        <p:input port="source">
                            <p:pipe step="add-metadata" port="fileset"/>
                        </p:input>
                    </p:identity>
                </p:otherwise>
            </p:choose>
            <p:choose name="update-html">
                <p:xpath-context>
                    <p:pipe step="package-doc" port="result"/>
                </p:xpath-context>
                <!--
                    * only update lang attributes when there is exactly one dc:language
                    * only update title element if there is at least one dc:title
                -->
                <p:when test="($update-lang-attributes='true' and count(/*/opf:metadata/dc:language)=1)
                              or $update-identifier-in-content-docs='true'
                              or ($update-title-in-content-docs='true' and exists(/*/opf:metadata/dc:title))">
                    <p:output port="fileset" primary="true"/>
                    <p:output port="in-memory" sequence="true">
                        <p:pipe step="update" port="result.in-memory"/>
                    </p:output>
                    <px:opf-spine-to-fileset>
                        <p:input port="source.in-memory">
                            <p:pipe step="update-package-doc" port="in-memory"/>
                        </p:input>
                    </px:opf-spine-to-fileset>
                    <px:fileset-load media-types="application/xhtml+xml" name="html">
                        <p:input port="in-memory">
                            <p:pipe step="update-package-doc" port="in-memory"/>
                        </p:input>
                    </px:fileset-load>
                    <p:sink/>
                    <p:identity>
                        <p:input port="source">
                            <p:pipe step="package-doc" port="result"/>
                        </p:input>
                    </p:identity>
                    <p:choose>
                        <p:when test="$update-lang-attributes='true' and count(/*/opf:metadata/dc:language)=1">
                            <p:variable name="language" select="/*/opf:metadata/dc:language/string(.)"/>
                            <p:identity px:message="Updating 'lang' attributes to '{$language}'"/>
                        </p:when>
                        <p:when test="$update-lang-attributes='true' and count(/*/opf:metadata/dc:language)=0">
                            <p:identity px:message-severity="WARNING"
                                        px:message="Not updating 'lang' attributes. No dc:language present in package document."/>
                        </p:when>
                        <p:when test="$update-lang-attributes='true'">
                            <p:identity px:message-severity="WARNING"
                                        px:message="Not updating 'lang' attributes. More than one dc:language present in package document."/>
                        </p:when>
                        <p:otherwise>
                            <p:identity/>
                        </p:otherwise>
                    </p:choose>
                    <p:choose>
                        <p:when test="$update-identifier-in-content-docs='true'">
                            <p:variable name="identifier"
                                        select="/*/opf:metadata/dc:identifier[@id=root()/*/@unique-identifier]/string(.)"/>
                            <p:identity px:message="Updating &lt;meta name='dc:identifier'&gt; elements to '{$identifier}'"/>
                        </p:when>
                        <p:otherwise>
                            <p:identity/>
                        </p:otherwise>
                    </p:choose>
                    <p:choose>
                        <p:when test="$update-title-in-content-docs='true' and exists(/*/opf:metadata/dc:title)">
                            <p:variable name="title" select="(/*/opf:metadata/dc:title)[1]/string(.)"/>
                            <p:identity px:message="Updating &lt;title&gt; elements to '{$title}'"/>
                        </p:when>
                        <p:when test="$update-lang-attributes='true' and count(/*/opf:metadata/dc:title)=0">
                            <p:identity px:message-severity="WARNING"
                                        px:message="Not updating &lt;title&gt; elements. No dc:title present in package document."/>
                        </p:when>
                        <p:otherwise>
                            <p:identity/>
                        </p:otherwise>
                    </p:choose>
                    <p:for-each name="updated-html">
                        <p:iteration-source>
                            <p:pipe step="html" port="result"/>
                        </p:iteration-source>
                        <p:output port="result"/>
                        <p:xslt>
                            <p:input port="source">
                                <p:pipe step="updated-html" port="current"/>
                                <p:pipe step="package-doc" port="result"/>
                            </p:input>
                            <p:input port="stylesheet">
                                <p:document href="html-derive-meta-from-package-doc.xsl"/>
                            </p:input>
                            <p:with-param name="update-lang-attributes" select="$update-lang-attributes"/>
                            <p:with-param name="update-identifier-in-content-docs" select="$update-identifier-in-content-docs"/>
                            <p:with-param name="update-title-in-content-docs" select="$update-title-in-content-docs"/>
                        </p:xslt>
                    </p:for-each>
                    <p:sink/>
                    <px:fileset-update name="update">
                        <p:input port="source.fileset">
                            <p:pipe step="update-package-doc" port="fileset"/>
                        </p:input>
                        <p:input port="source.in-memory">
                            <p:pipe step="update-package-doc" port="in-memory"/>
                        </p:input>
                        <p:input port="update.fileset">
                            <p:pipe step="html" port="result.fileset"/>
                        </p:input>
                        <p:input port="update.in-memory">
                            <p:pipe step="updated-html" port="result"/>
                        </p:input>
                    </px:fileset-update>
                </p:when>
                <p:otherwise>
                    <p:output port="fileset" primary="true"/>
                    <p:output port="in-memory" sequence="true">
                        <p:pipe step="update-package-doc" port="in-memory"/>
                    </p:output>
                    <p:identity/>
                </p:otherwise>
            </p:choose>
        </p:when>
        <p:otherwise>
            <p:output port="fileset" primary="true"/>
            <p:output port="in-memory" sequence="true">
                <p:pipe step="add-metadata" port="in-memory"/>
            </p:output>
            <p:identity/>
        </p:otherwise>
    </p:choose>

    <!--
        Add missing headings
    -->
    <p:choose name="add-missing-headings">
        <p:when test="$ensure-section-headings='true'">
            <p:output port="fileset" primary="true"/>
            <p:output port="in-memory" sequence="true">
                <p:pipe step="update" port="result.in-memory"/>
            </p:output>
            <px:fileset-load media-types="application/xhtml+xml" name="html">
                <p:input port="in-memory">
                    <p:pipe step="update-lang-attributes-and-html-meta" port="in-memory"/>
                </p:input>
            </px:fileset-load>
            <p:for-each name="fixed-html">
                <p:output port="result"/>
                <p:choose>
                    <p:when test="(//html:body|//html:section|//html:nav|//html:article|//html:aside)/@aria-label">
                        <px:html-outline fix-untitled-sections="imply-heading-from-aria-label">
                            <p:input port="input-toc">
                                <p:pipe step="toc" port="result"/>
                            </p:input>
                        </px:html-outline>
                    </p:when>
                    <p:otherwise>
                        <p:identity/>
                    </p:otherwise>
                </p:choose>
            </p:for-each>
            <p:sink/>
            <p:group name="toc">
                <p:output port="result"/>
                <p:identity>
                    <p:input port="source">
                        <p:pipe step="update-lang-attributes-and-html-meta" port="fileset"/>
                    </p:input>
                </p:identity>
                <p:choose>
                    <p:when test="exists(//d:file[@role='nav'])">
                        <px:fileset-load>
                            <p:input port="in-memory">
                                <p:pipe step="update-lang-attributes-and-html-meta" port="in-memory"/>
                            </p:input>
                            <p:with-option name="href" select="//d:file[@role='nav'][1]/@href"/>
                        </px:fileset-load>
                        <p:add-xml-base>
                            <!-- Not sure why this is needed. Omitted this triggers a base URI error
                                 in px:html-outline. Bug? -->
                        </p:add-xml-base>
                        <p:filter select="//html:nav[tokenize(@epub:type,'\s+')='toc'][1]/html:ol"/>
                    </p:when>
                    <p:otherwise>
                        <p:identity>
                            <p:input port="source">
                                <p:empty/>
                            </p:input>
                        </p:identity>
                    </p:otherwise>
                </p:choose>
            </p:group>
            <p:sink/>
            <px:fileset-update name="update">
                <p:input port="source.fileset">
                    <p:pipe step="update-lang-attributes-and-html-meta" port="fileset"/>
                </p:input>
                <p:input port="source.in-memory">
                    <p:pipe step="update-lang-attributes-and-html-meta" port="in-memory"/>
                </p:input>
                <p:input port="update.fileset">
                    <p:pipe step="html" port="result.fileset"/>
                </p:input>
                <p:input port="update.in-memory">
                    <p:pipe step="fixed-html" port="result"/>
                </p:input>
            </px:fileset-update>
        </p:when>
        <p:otherwise>
            <p:output port="fileset" primary="true"/>
            <p:output port="in-memory" sequence="true">
                <p:pipe step="update-lang-attributes-and-html-meta" port="in-memory"/>
            </p:output>
            <p:identity/>
        </p:otherwise>
    </p:choose>

    <!--
        Page number fixes
    -->
    <p:group name="fix-pagenum">
        <p:output port="fileset" primary="true"/>
        <p:output port="in-memory" sequence="true">
            <p:pipe step="update" port="result.in-memory"/>
        </p:output>
        <!--
            Read navigation document and label page break elements with epub:type="pagebreak" if
            missing (and also add title attribute if missing)
        -->
        <px:epub3-label-pagebreaks-from-nav name="label-pagebreaks-from-nav">
            <p:input port="source.in-memory">
                <p:pipe step="add-missing-headings" port="in-memory"/>
            </p:input>
        </px:epub3-label-pagebreaks-from-nav>
        <px:fileset-load media-types="application/xhtml+xml" name="html">
            <p:input port="in-memory">
                <p:pipe step="label-pagebreaks-from-nav" port="result.in-memory"/>
            </p:input>
        </px:fileset-load>
        <p:for-each name="fixed-html">
            <p:output port="result"/>
            <!--
                Convert DPUB-ARIA role="doc-pagebreak" to epub:type="pagebreak"
            -->
            <p:label-elements match="*[@role='doc-pagebreak']" attribute="epub:type" replace="true"
                              label="string-join(distinct-values((@epub:type/tokenize(.,'\s+')[not(.='')],'pagebreak')),' ')"/>
            <!--
                Generate text for empty page numbers
            -->
            <p:choose name="ensure-pagenum-text">
                <p:when test="$ensure-pagenum-text=('true','hidden')">
                    <p:xslt>
                        <p:input port="stylesheet">
                            <p:document href="ensure-pagenum-text.xsl"/>
                        </p:input>
                        <p:with-param name="hidden" select="$ensure-pagenum-text='hidden'"/>
                    </p:xslt>
                </p:when>
                <p:otherwise>
                    <p:identity/>
                </p:otherwise>
            </p:choose>
        </p:for-each>
        <px:fileset-update name="update">
            <p:input port="source.fileset">
                <p:pipe step="label-pagebreaks-from-nav" port="result.fileset"/>
            </p:input>
            <p:input port="source.in-memory">
                <p:pipe step="label-pagebreaks-from-nav" port="result.in-memory"/>
            </p:input>
            <p:input port="update.fileset">
                <p:pipe step="html" port="result.fileset"/>
            </p:input>
            <p:input port="update.in-memory">
                <p:pipe step="fixed-html" port="result"/>
            </p:input>
        </px:fileset-update>
    </p:group>

    <!--
        Perform TTS or only sentence detection or nothing
    -->
    <p:group name="add-mediaoverlays" px:progress="1/2">
        <p:output port="fileset" primary="true"/>
        <p:output port="in-memory" sequence="true">
            <p:pipe step="skip-if-disabled" port="in-memory"/>
        </p:output>
        <p:output port="temp-audio.fileset">
            <p:pipe step="skip-if-disabled" port="temp-audio.fileset"/>
        </p:output>
        <p:output port="log">
            <p:pipe step="skip-if-disabled" port="log"/>
        </p:output>
        <px:fileset-filter media-types="application/oebps-package+xml"/>
        <p:delete match="d:file[preceding::d:file]"/>
        <px:fileset-load name="package-document">
            <p:input port="in-memory">
                <p:pipe step="fix-pagenum" port="in-memory"/>
            </p:input>
        </px:fileset-load>
        <p:choose name="skip-if-disabled" px:progress="1">
            <p:when test="$tts='true' or $tts='default' and not(//opf:item/@media-overlay)" px:message="Performing TTS">
                <p:output port="fileset" primary="true"/>
                <p:output port="in-memory" sequence="true">
                    <p:pipe step="add" port="result.in-memory"/>
                </p:output>
                <p:output port="temp-audio.fileset">
                    <p:pipe step="mo" port="original-audio.fileset"/>
                </p:output>
                <p:output port="log">
                    <p:pipe step="tts" port="log"/>
                </p:output>

                <!--
                    perform TTS
                -->
                <p:group name="tts" px:progress="1">
                    <p:output port="result.fileset" primary="true"/>
                    <p:output port="result.in-memory" sequence="true">
                        <p:pipe step="update" port="result.in-memory"/>
                    </p:output>
                    <p:output port="audio-map">
                        <p:pipe step="do-tts" port="audio-map"/>
                    </p:output>
                    <p:output port="log" sequence="true">
                        <p:pipe step="do-tts" port="log"/>
                    </p:output>
                    <!-- don't perform TTS on documents that are not in spine -->
                    <px:opf-spine-to-fileset name="spine">
                        <p:input port="source.fileset">
                            <p:pipe step="fix-pagenum" port="fileset"/>
                        </p:input>
                        <p:input port="source.in-memory">
                            <p:pipe step="fix-pagenum" port="in-memory"/>
                        </p:input>
                    </px:opf-spine-to-fileset>
                    <px:tts-for-epub3 name="do-tts" audio="true" px:progress="1">
                        <p:input port="source.in-memory">
                            <p:pipe step="fix-pagenum" port="in-memory"/>
                        </p:input>
                        <p:input port="config">
                            <p:pipe step="main" port="tts-config"/>
                        </p:input>
                        <p:with-option name="include-log" select="$include-tts-log"/>
                        <p:with-option name="temp-dir" select="$temp-dir"/>
                    </px:tts-for-epub3>
                    <p:sink/>
                    <px:fileset-update name="update">
                        <p:input port="source.fileset">
                            <p:pipe step="fix-pagenum" port="fileset"/>
                        </p:input>
                        <p:input port="source.in-memory">
                            <p:pipe step="fix-pagenum" port="in-memory"/>
                        </p:input>
                        <p:input port="update.fileset">
                            <p:pipe step="do-tts" port="result.fileset"/>
                        </p:input>
                        <p:input port="update.in-memory">
                            <p:pipe step="do-tts" port="result.in-memory"/>
                        </p:input>
                    </px:fileset-update>
                </p:group>

                <!--
                    generate SMIL files and copy audio files
                -->

                <px:epub3-create-mediaoverlays flatten="true" name="mo">
                    <p:input port="source.in-memory">
                        <p:pipe step="tts" port="result.in-memory"/>
                    </p:input>
                    <p:input port="audio-map">
                        <p:pipe step="tts" port="audio-map"/>
                    </p:input>
                    <p:with-option name="mediaoverlay-dir" select="resolve-uri('mo/',base-uri(/*))">
                        <p:pipe step="package-document" port="result"/>
                    </p:with-option>
                    <p:with-option name="audio-dir" select="resolve-uri('audio/',base-uri(/*))">
                        <p:pipe step="package-document" port="result"/>
                    </p:with-option>
                </px:epub3-create-mediaoverlays>
                <p:sink/>

                <!--
                    update EPUB with mediaoverlays
                -->

                <!-- not declaring "media" prefix because this appears to cause issues in Adobe
                     Digital Editions -->
                <px:epub3-add-mediaoverlays declare-media-prefix="false" name="add">
                    <p:input port="source.fileset">
                        <p:pipe step="tts" port="result.fileset"/>
                    </p:input>
                    <p:input port="source.in-memory">
                        <p:pipe step="tts" port="result.in-memory"/>
                    </p:input>
                    <p:input port="mo.fileset">
                        <p:pipe step="mo" port="result.fileset"/>
                    </p:input>
                    <p:input port="mo.in-memory">
                        <p:pipe step="mo" port="result.in-memory"/>
                    </p:input>
                </px:epub3-add-mediaoverlays>
            </p:when>
            <p:when test="$sentence-detection='true'" px:message="Performing sentence detection">
                <!--
                    perform sentence detection
                -->
                <p:output port="fileset" primary="true"/>
                <p:output port="in-memory" sequence="true">
                    <p:pipe step="update" port="result.in-memory"/>
                </p:output>
                <p:output port="temp-audio.fileset">
                    <p:inline><d:fileset/></p:inline>
                </p:output>
                <p:output port="log" sequence="true">
                    <p:empty/>
                </p:output>
                <px:opf-spine-to-fileset name="spine">
                    <p:input port="source.fileset">
                        <p:pipe step="fix-pagenum" port="fileset"/>
                    </p:input>
                    <p:input port="source.in-memory">
                        <p:pipe step="fix-pagenum" port="in-memory"/>
                    </p:input>
                </px:opf-spine-to-fileset>
                <px:fileset-load media-types="application/xhtml+xml" name="html">
                    <p:input port="in-memory">
                        <p:pipe step="fix-pagenum" port="in-memory"/>
                    </p:input>
                </px:fileset-load>
                <p:for-each name="sentence-detection" px:progress="1">
                    <p:output port="result"/>
                    <px:html-break-detect name="break-detect">
                        <p:with-option name="id-prefix" select="concat(p:iteration-position(),'-')"/>
                        <p:with-option name="sentence-attr" select="if ($sentence-class!='') then 'class' else ''"/>
                        <p:with-option name="sentence-attr-val" select="$sentence-class"/>
                    </px:html-break-detect>
                    <px:isolate-skippable match="*[@epub:type/tokenize(.,'\s+')=('pagebreak','noteref')]|
                                                 *[@role='doc-pagebreak']|
                                                 *[@role='doc-noteref']">
                        <p:input port="sentence-ids">
                            <p:pipe step="break-detect" port="sentence-ids"/>
                        </p:input>
                        <p:with-option name="id-prefix" select="concat('i', p:iteration-position())"/>
                    </px:isolate-skippable>
                    <px:html-unwrap-words>
                        <!-- only keep the sentences, not the words -->
                    </px:html-unwrap-words>
                </p:for-each>
                <p:sink/>
                <px:fileset-update name="update">
                    <p:input port="source.fileset">
                        <p:pipe step="fix-pagenum" port="fileset"/>
                    </p:input>
                    <p:input port="source.in-memory">
                        <p:pipe step="fix-pagenum" port="in-memory"/>
                    </p:input>
                    <p:input port="update.fileset">
                        <p:pipe step="html" port="result.fileset"/>
                    </p:input>
                    <p:input port="update.in-memory">
                        <p:pipe step="sentence-detection" port="result"/>
                    </p:input>
                </px:fileset-update>
            </p:when>
            <p:otherwise>
                <p:output port="fileset" primary="true"/>
                <p:output port="in-memory" sequence="true">
                    <p:pipe step="fix-pagenum" port="in-memory"/>
                </p:output>
                <p:output port="temp-audio.fileset">
                    <p:inline><d:fileset/></p:inline>
                </p:output>
                <p:output port="log" sequence="true">
                    <p:empty/>
                </p:output>
                <p:identity>
                    <p:input port="source">
                        <p:pipe step="fix-pagenum" port="fileset"/>
                    </p:input>
                </p:identity>
            </p:otherwise>
        </p:choose>
    </p:group>
    
    <p:choose name="add-braille-rendition" px:progress="1/2">
        <p:when test="not($braille='true')">
            <p:output port="fileset" primary="true"/>
            <p:output port="in-memory" sequence="true">
                <p:pipe step="add-mediaoverlays" port="in-memory"/>
            </p:output>
            <p:identity/>
        </p:when>
        <p:otherwise>
            <p:output port="fileset" primary="true"/>
            <p:output port="in-memory" sequence="true">
                <p:pipe step="update-container" port="in-memory"/>
            </p:output>
            
            <!--
                load default rendition package document
            -->
            
            <px:fileset-filter media-types="application/oebps-package+xml"/>
            <p:delete match="d:file[preceding::d:file]"/>
            <px:fileset-load name="default-rendition.package-document">
                <p:input port="in-memory">
                    <p:pipe step="add-mediaoverlays" port="in-memory"/>
                </p:input>
            </px:fileset-load>
            
            <!--
                create braille rendition file set
            -->
            
            <p:group name="braille-rendition.fileset">
                <p:output port="fileset" primary="true"/>
                <p:output port="in-memory" sequence="true">
                    <p:pipe step="apply" port="result.in-memory"/>
                </p:output>
                <p:output port="mapping">
                    <p:pipe step="mapping" port="result"/>
                </p:output>
                <p:xslt name="mapping">
                    <p:input port="stylesheet">
                        <p:document href="braille-rendition.fileset.xsl"/>
                    </p:input>
                    <p:with-param name="content-media-types" select="$content-media-types"/>
                    <p:with-param name="braille-rendition.package-document.base"
                                  select="resolve-uri('EPUB/package-braille.opf',base-uri(/*))">
                        <p:pipe step="maybe-copy" port="fileset"/>
                    </p:with-param>
                </p:xslt>
                <p:sink/>
                <!--
                    update cross references
                -->
                <px:epub-update-links name="update-links">
                    <p:input port="source.fileset">
                        <p:pipe step="add-mediaoverlays" port="fileset"/>
                    </p:input>
                    <p:input port="source.in-memory">
                        <p:pipe step="add-mediaoverlays" port="in-memory"/>
                    </p:input>
                    <p:input port="mapping">
                        <p:pipe step="mapping" port="result"/>
                    </p:input>
                </px:epub-update-links>
                <!--
                    perform rename
                -->
                <px:fileset-apply name="apply">
                    <p:input port="source.in-memory">
                        <p:pipe step="update-links" port="result.in-memory"/>
                    </p:input>
                    <p:input port="mapping">
                        <p:pipe step="mapping" port="result"/>
                    </p:input>
                </px:fileset-apply>
            </p:group>
            
            <!--
                process braille rendition xhtml documents
            -->
            
            <p:group name="braille-rendition.process-html" px:message="Translating to braille">
                <p:output port="result.fileset" primary="true"/>
                <p:output port="result.in-memory" sequence="true">
                    <p:pipe step="update-fileset" port="result.in-memory"/>
                </p:output>
                <p:output port="html.fileset">
                    <p:pipe step="load" port="result.fileset"/>
                </p:output>
                <p:output port="html.in-memory" sequence="true">
                    <p:pipe step="for-each" port="html"/>
                </p:output>
                <p:output port="css.fileset">
                    <p:pipe step="css.fileset" port="result"/>
                </p:output>
                <p:output port="css.in-memory" sequence="true">
                    <p:pipe step="for-each" port="css"/>
                </p:output>
                <px:fileset-load name="load">
                    <p:input port="in-memory">
                        <p:pipe step="braille-rendition.fileset" port="in-memory"/>
                    </p:input>
                    <p:with-option name="media-types" select="$content-media-types"/>
                </px:fileset-load>
                <p:for-each name="for-each">
                    <p:output port="html" primary="true"/>
                    <p:output port="css" sequence="true">
                        <p:pipe step="extract-css" port="css"/>
                    </p:output>
                    <p:variable name="lang" select="(/*/opf:metadata/dc:language[not(@refines)])[1]/text()">
                        <p:pipe port="result" step="default-rendition.package-document"/>
                    </p:variable>
                    <px:message message="Generating $1" severity="INFO">
                        <p:with-option name="param1" select="substring-after(base-uri(/*),'!/')"/>
                    </px:message>
                    <p:choose>
                        <p:when test="$apply-document-specific-stylesheets='true'">
                            <px:message severity="DEBUG" message="Inlining document-specific CSS"/>
                            <!-- media="braille" would be more appropriate, see https://github.com/braillespecs/braille-css/issues/1 -->
                            <px:apply-stylesheets type="text/css text/scss" media="embossed">
                                <p:input port="context">
                                    <p:pipe step="add-mediaoverlays" port="in-memory"/>
                                </p:input>
                            </px:apply-stylesheets>
                        </p:when>
                        <p:otherwise>
                            <p:delete match="@style"/>
                        </p:otherwise>
                    </p:choose>
                    <css:delete-stylesheets/>
                    <!-- media="braille" would be more appropriate, see https://github.com/braillespecs/braille-css/issues/1 -->
                    <px:apply-stylesheets type="text/css text/scss" media="embossed">
                        <p:with-option name="stylesheets" select="($stylesheet,$default-stylesheet)[not(.='')][1]"/>
                    </px:apply-stylesheets>
                    <px:transform name="transform">
                        <p:with-option name="query" select="concat('(input:html)(input:css)(output:html)(output:css)(output:braille)',
                                                                   $braille-translator,
                                                                   '(locale:',$lang,')')"/>
                    </px:transform>
                    <p:group name="extract-css">
                        <p:output port="result" primary="true">
                            <p:pipe step="extract-css.result" port="result"/>
                        </p:output>
                        <p:output port="css" sequence="true">
                            <p:pipe step="css" port="result"/>
                        </p:output>
                        <css:extract name="extract"/>
                        <p:delete match="@style" name="without-css"/>
                        <p:choose>
                            <p:xpath-context>
                                <p:pipe step="extract" port="stylesheet"/>
                            </p:xpath-context>
                            <p:when test="normalize-space(string(/*))=''">
                                <p:identity/>
                            </p:when>
                            <p:otherwise>
                                <p:add-attribute match="/html:link" attribute-name="href" name="css-link">
                                    <p:input port="source">
                                        <p:inline xmlns="http://www.w3.org/1999/xhtml">
                                            <link rel="stylesheet" type="text/css" media="embossed"/>
                                        </p:inline>
                                    </p:input>
                                    <p:with-option name="attribute-value" select="replace(base-uri(/*),'^.*/(([^/]+)\.x?html|([^/]+))$','$2$3.css')"/>
                                </p:add-attribute>
                                <!--
                                    assuming there is one and only one head element
                                -->
                                <p:insert match="html:head" position="last-child">
                                    <p:input port="source">
                                        <p:pipe step="without-css" port="result"/>
                                    </p:input>
                                    <p:input port="insertion">
                                        <p:pipe step="css-link" port="result"/>
                                    </p:input>
                                </p:insert>
                            </p:otherwise>
                        </p:choose>
                        <p:identity name="extract-css.result"/>
                        <p:identity>
                            <p:input port="source">
                                <p:pipe step="extract" port="stylesheet"/>
                            </p:input>
                        </p:identity>
                        <p:choose>
                            <p:when test="normalize-space(string(/*))=''">
                                <p:identity>
                                    <p:input port="source">
                                        <p:empty/>
                                    </p:input>
                                </p:identity>
                            </p:when>
                            <p:otherwise>
                                <px:set-base-uri>
                                    <!--
                                        using "base-uri(parent::*)" because link has the base-uri of this XProc file
                                    -->
                                    <p:with-option name="base-uri"
                                                   select="//html:link[@rel='stylesheet' and @type='text/css' and @media='embossed']
                                                           /resolve-uri(@href,base-uri(parent::*))">
                                        <p:pipe step="extract-css.result" port="result"/>
                                    </p:with-option>
                                </px:set-base-uri>
                            </p:otherwise>
                        </p:choose>
                        <p:identity name="css"/>
                    </p:group>
                </p:for-each>
                <p:sink/>
                <!--
                    extracted css fileset
                -->
                <px:fileset-create name="base"/>
                <p:for-each>
                    <p:iteration-source>
                        <p:pipe step="for-each" port="css"/>
                    </p:iteration-source>
                    <px:fileset-add-entry>
                        <p:input port="source">
                            <p:pipe step="base" port="result"/>
                        </p:input>
                        <p:with-option name="href" select="base-uri(/*)"/>
                        <p:with-option name="media-type" select="/c:result/@content-type"/> <!-- text/plain -->
                    </px:fileset-add-entry>
                </p:for-each>
                <px:fileset-join name="css.fileset"/>
                <p:sink/>
                <!--
                    update braille rendition fileset
                -->
                <px:fileset-join>
                    <p:input port="source">
                        <p:pipe step="braille-rendition.fileset" port="fileset"/>
                        <p:pipe step="css.fileset" port="result"/>
                    </p:input>
                </px:fileset-join>
                <px:fileset-update name="update-fileset">
                    <p:input port="source.in-memory">
                        <p:pipe step="braille-rendition.fileset" port="in-memory"/>
                        <p:pipe step="for-each" port="css"/>
                    </p:input>
                    <p:input port="update.fileset">
                        <p:pipe step="load" port="result.fileset"/>
                    </p:input>
                    <p:input port="update.in-memory">
                        <p:pipe step="for-each" port="html"/>
                    </p:input>
                </px:fileset-update>
            </p:group>
            
            <!--
                process braille rendition package document
            -->
            
            <p:group name="braille-rendition.process-package-doc">
                <p:output port="fileset" primary="true"/>
                <p:output port="in-memory" sequence="true">
                    <p:pipe step="update-fileset" port="result.in-memory"/>
                </p:output>
                <px:fileset-load media-types="application/oebps-package+xml" name="copied-package-doc">
                    <p:input port="in-memory">
                        <p:pipe step="braille-rendition.process-html" port="result.in-memory"/>
                    </p:input>
                </px:fileset-load>
                <p:sink/>
                <!--
                    change dc:language and dcterms:modified, and add extracted css files
                -->
                <p:xslt name="package-doc">
                    <p:input port="source">
                        <p:pipe step="copied-package-doc" port="result"/>
                        <p:pipe step="braille-rendition.process-html" port="css.fileset"/>
                        <p:pipe step="braille-rendition.process-html" port="html.in-memory"/>
                    </p:input>
                    <p:input port="stylesheet">
                        <p:document href="braille-rendition.package-document.xsl"/>
                    </p:input>
                    <p:input port="parameters">
                        <p:empty/>
                    </p:input>
                </p:xslt>
                <p:sink/>
                <px:fileset-update name="update-fileset">
                    <p:input port="source.fileset">
                        <p:pipe step="braille-rendition.process-html" port="result.fileset"/>
                    </p:input>
                    <p:input port="source.in-memory">
                        <p:pipe step="braille-rendition.process-html" port="result.in-memory"/>
                    </p:input>
                    <p:input port="update.fileset">
                        <p:pipe step="copied-package-doc" port="result.fileset"/>
                    </p:input>
                    <p:input port="update.in-memory">
                        <p:pipe step="package-doc" port="result"/>
                    </p:input>
                </px:fileset-update>
            </p:group>
            
            <!--
                final braille rendition package document
            -->
            <px:fileset-load media-types="application/oebps-package+xml" name="braille-rendition.package-document">
                <p:input port="in-memory">
                    <p:pipe step="braille-rendition.process-package-doc" port="in-memory"/>
                </p:input>
            </px:fileset-load>
            <p:sink/>
            
            <!--
                add braille rendition
            -->
            
            <p:group name="add-rendition">
                <p:output port="fileset" primary="true"/>
                <p:output port="in-memory" sequence="true">
                    <p:pipe step="add-mediaoverlays" port="in-memory"/>
                    <p:pipe step="braille-rendition.process-package-doc" port="in-memory"/>
                </p:output>
                <px:fileset-join>
                    <p:input port="source">
                        <p:pipe step="add-mediaoverlays" port="fileset"/>
                        <p:pipe step="braille-rendition.process-package-doc" port="fileset"/>
                    </p:input>
                </px:fileset-join>
            </p:group>
            
            <!--
                create and add metadata.xml
            -->
            
            <p:group name="add-metadata-xml">
                <p:output port="fileset" primary="true">
                    <p:pipe step="add-entry" port="result"/>
                </p:output>
                <p:output port="in-memory" sequence="true">
                    <p:pipe step="add-entry" port="result.in-memory"/>
                </p:output>
                <px:fileset-add-entry name="add-entry">
                    <p:input port="source.in-memory">
                        <p:pipe step="add-rendition" port="in-memory"/>
                    </p:input>
                    <p:input port="entry">
                        <p:pipe step="metadata" port="result"/>
                    </p:input>
                </px:fileset-add-entry>
                <p:sink/>
                <p:group name="metadata">
                    <p:output port="result"/>
                    <p:identity>
                        <p:input port="source">
                            <p:inline xmlns="http://www.idpf.org/2007/opf">
        <metadata xmlns:dcterms="http://purl.org/dc/terms/"/></p:inline>
                        </p:input>
                    </p:identity>
                    <p:add-attribute match="/opf:metadata" attribute-name="unique-identifier">
                        <p:with-option name="attribute-value" select="/opf:package/@unique-identifier">
                            <p:pipe step="braille-rendition.package-document" port="result"/>
                        </p:with-option>
                    </p:add-attribute>
                    <p:insert match="/opf:metadata" position="last-child">
                        <p:input port="insertion" select="for $unique-identifier in /opf:package/@unique-identifier
                                                          return /opf:package/opf:metadata/dc:identifier[@id=$unique-identifier]">
                            <p:pipe step="braille-rendition.package-document" port="result"/>
                        </p:input>
                    </p:insert>
                    <p:insert match="/opf:metadata" position="last-child">
                        <p:input port="insertion" select="/opf:package/opf:metadata/opf:meta[@property='dcterms:modified']">
                            <p:pipe step="braille-rendition.package-document" port="result"/>
                        </p:input>
                    </p:insert>
                    <px:set-base-uri>
                        <p:with-option name="base-uri" select="resolve-uri('META-INF/metadata.xml',base-uri(/*))">
                            <p:pipe step="maybe-copy" port="fileset"/>
                        </p:with-option>
                    </px:set-base-uri>
                </p:group>
                <p:sink/>
            </p:group>
            
            <!--
                create and add rendition mapping document
            -->
            <p:group name="add-rendition-mapping">
                <p:output port="fileset" primary="true">
                    <p:pipe step="add-entry" port="result"/>
                </p:output>
                <p:output port="in-memory" sequence="true">
                    <p:pipe step="add-entry" port="result.in-memory"/>
                </p:output>
                <px:fileset-add-entry name="add-entry">
                    <p:input port="source.in-memory">
                        <p:pipe step="add-metadata-xml" port="in-memory"/>
                    </p:input>
                    <p:input port="entry">
                        <p:pipe step="rendition-mapping" port="result"/>
                    </p:input>
                    <p:with-param port="file-attributes" name="indent" select="'true'"/>
                </px:fileset-add-entry>
                <p:sink/>
                <p:group name="rendition-mapping">
                    <p:output port="result"/>
                    <p:for-each name="resource-maps">
                        <p:iteration-source select="/*/d:file">
                            <p:pipe step="braille-rendition.process-html" port="html.fileset"/>
                        </p:iteration-source>
                        <p:output port="result"/>
                        <p:variable name="braille-rendition.html.base" select="/d:file/resolve-uri(@href,base-uri(.))"/>
                        <p:variable name="default-rendition.html.base"
                                    select="//d:file[resolve-uri(@href,base-uri(.))=$braille-rendition.html.base]
                                            /resolve-uri(@original-href,base-uri(.))">
                            <p:pipe step="braille-rendition.fileset" port="mapping"/>
                        </p:variable>
                        <p:xslt template-name="main">
                            <p:input port="stylesheet">
                                <p:document href="resource-map.xsl"/>
                            </p:input>
                            <p:input port="source">
                                <p:pipe step="default-rendition.package-document" port="result"/>
                                <p:pipe step="braille-rendition.package-document" port="result"/>
                            </p:input>
                            <p:with-param name="default-rendition.html.base" select="$default-rendition.html.base"/>
                            <p:with-param name="braille-rendition.html.base" select="$braille-rendition.html.base"/>
                            <p:with-param name="rendition-mapping.base" select="resolve-uri('EPUB/renditionMapping.html',base-uri(/*))">
                                <p:pipe step="maybe-copy" port="fileset"/>
                            </p:with-param>
                        </p:xslt>
                    </p:for-each>
                    <p:sink/>
                    <p:insert match="//html:nav" position="last-child">
                        <p:input port="source">
                            <p:inline xmlns="http://www.w3.org/1999/xhtml">
        <html>
           <head>
              <meta charset="utf-8"/>
           </head>
           <body>
              <nav epub:type="resource-map"/>
           </body>
        </html></p:inline>
                        </p:input>
                        <p:input port="insertion" select="/html:nav[@epub:type='resource-map']/*">
                            <p:pipe step="resource-maps" port="result"/>
                        </p:input>
                    </p:insert>
                    <px:set-base-uri>
                        <p:with-option name="base-uri" select="resolve-uri('EPUB/renditionMapping.html',base-uri(/*))">
                            <p:pipe step="maybe-copy" port="fileset"/>
                        </p:with-option>
                    </px:set-base-uri>
                </p:group>
                <p:sink/>
            </p:group>
            
            <!--
                update container.xml
            -->
            
            <p:group name="update-container">
                <p:output port="fileset" primary="true">
                    <p:pipe step="update-fileset" port="result.fileset"/>
                </p:output>
                <p:output port="in-memory" sequence="true">
                    <p:pipe step="update-fileset" port="result.in-memory"/>
                </p:output>
                <px:fileset-update name="update-fileset">
                    <p:input port="source.in-memory">
                        <p:pipe step="add-rendition-mapping" port="in-memory"/>
                    </p:input>
                    <p:input port="update.fileset">
                        <p:pipe step="original-container" port="result.fileset"/>
                    </p:input>
                    <p:input port="update.in-memory">
                        <p:pipe step="container" port="result"/>
                    </p:input>
                </px:fileset-update>
                <p:sink/>
                <px:fileset-load name="original-container">
                    <p:input port="fileset">
                        <p:pipe step="add-rendition-mapping" port="fileset"/>
                    </p:input>
                    <p:input port="in-memory">
                        <p:pipe step="add-rendition-mapping" port="in-memory"/>
                    </p:input>
                    <p:with-option name="href" select="resolve-uri('META-INF/container.xml',base-uri(/*))">
                        <p:pipe step="maybe-copy" port="fileset"/>
                    </p:with-option>
                </px:fileset-load>
                <p:group name="container">
                    <p:output port="result"/>
                    <p:insert match="/ocf:container/ocf:rootfiles">
                        <p:input port="insertion">
                            <p:inline xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
                                <rootfile full-path="EPUB/package-braille.opf" media-type="application/oebps-package+xml"
                                          rendition:accessMode="tactile" rendition:label="Pre-translated to braille"/>
                            </p:inline>
                        </p:input>
                        <p:with-option name="position" select="if ($set-default-rendition-to-braille='true')
                                                               then 'first-child'
                                                               else 'last-child'"/>
                    </p:insert>
                    <p:add-attribute match="/ocf:container/ocf:rootfiles/ocf:rootfile[last()]" attribute-name="rendition:language">
                        <p:with-option name="attribute-value" select="/opf:package/opf:metadata/dc:language[1]/string(.)">
                            <p:pipe step="braille-rendition.package-document" port="result"/>
                        </p:with-option>
                    </p:add-attribute>
                    <p:add-attribute match="/ocf:container/ocf:rootfiles/ocf:rootfile[last()]" attribute-name="rendition:layout">
                        <p:with-option name="attribute-value"
                                       select="(/opf:package/opf:metadata/opf:meta[@property='rendition:layout']/string(.),'reflowable')[1]">
                            <p:pipe step="braille-rendition.package-document" port="result"/>
                        </p:with-option>
                    </p:add-attribute>
                    <p:insert position="last-child" match="/ocf:container">
                        <p:input port="insertion">
                            <p:inline xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
                                <link href="EPUB/renditionMapping.html" rel="mapping" media-type="application/xhtml+xml"/>
                            </p:inline>
                        </p:input>
                    </p:insert>
                    <px:set-base-uri>
                        <p:with-option name="base-uri" select="base-uri(/*)">
                            <p:pipe step="original-container" port="result"/>
                        </p:with-option>
                    </px:set-base-uri>
                </p:group>
                <p:sink/>
            </p:group>
        </p:otherwise>
    </p:choose>

    <!--
        Pretty print package documents
    -->
    <p:add-attribute match="d:file[@media-type='application/oebps-package+xml']"
                     attribute-name="indent" attribute-value="true"/>

</p:declare-step>

/***************************************************************/
/* This class was generated by ds-to-spi-annotations-processor */
/***************************************************************/

#if( ${component.packageName} )
package ${component.packageName};

#end
public class ${component.spiClassName}
#if( !${component.proxy} )
       extends ${component.qualifiedClassName}
#end
       implements org.daisy.common.spi.ServiceWithProperties
#if( ${component.immediate} )
                , org.daisy.common.spi.CreateOnStart ## maybe this is not exactly what we want but it's close enough
#end
#if( ${component.proxy} )
#foreach($service in ${component.services})
                , ${service.name}
#end
#end
{
	
	private static final org.slf4j.Logger spi_log = org.slf4j.LoggerFactory.getLogger(${component.spiClassName}.class);
	
	private final java.util.Map spi_props;
	private boolean spi_deactivated = false;
	
#if( ${component.proxy} )
#if( ${component.classLoader} )
	private final Object delegate;
#else
	private final ${component.qualifiedClassName} delegate;
#end
#end

	public ${component.spiClassName}() {
#if( ${component.proxy} )
#if( ${component.classLoader} )
		try {
			// FIXME: use same classloader if multiple components have the same @LoadWith
			ClassLoader classLoader = (ClassLoader)Class.forName("${component.classLoader}").newInstance();
			delegate = classLoader.loadClass("${component.qualifiedClassName}").newInstance();
		} catch (ClassNotFoundException |
		         InstantiationException |
		         IllegalAccessException e) {
			throw new RuntimeException(e);
		}
#else
		delegate = new ${component.qualifiedClassName}();
#end
#else
		super();
#end
		spi_log.trace("Creating ${component.className}");
		spi_props = new java.util.HashMap();
		spi_props.put("component.name", "${component.name}");
#foreach($property in ${component.properties})
		spi_props.put(${property.keyLiteral}, ${property.valueLiteral});
#end
#foreach($reference in ${component.references})
		{
			spi_log.trace("Binding ${reference.service} services...");
			// cardinality: ${reference.cardinality}
#if( ${reference.cardinality} == "1..1" )
			int minRef = 1;
			int maxRef = 1;
#elseif( ${reference.cardinality} == "1..n" )
			int minRef = 1;
			int maxRef = -1;
#elseif( ${reference.cardinality} == "0..1" )
			int minRef = 0;
			int maxRef = 1;
#else
			int minRef = 0;
			int maxRef = -1;
#end
			int refCount = 0;
			try {
				java.util.Iterator<${reference.service}> services
					= org.daisy.common.spi.ServiceLoader.load(${reference.service}.class).iterator();
#if( ${reference.filter} )
				org.osgi.framework.Filter filter = org.osgi.framework.FrameworkUtil.createFilter(${reference.filter});
#end
				while (services.hasNext()) {
					try {
						${reference.service} service = services.next();
#if( ${reference.filter} )
						if (!(service instanceof org.daisy.common.spi.ServiceWithProperties
						      && filter.matches(((org.daisy.common.spi.ServiceWithProperties)service).spi_getProperties()))) {
							spi_log.trace("Service " + service + " does not match " + ${reference.filter});
							continue; }
#end
#if( ${reference.propertiesArgumentType} )
						${reference.propertiesArgumentType.getName()} props = new ${reference.propertiesArgumentType.getName()}();
						for (java.util.Map.Entry kv : (java.util.Set<java.util.Map.Entry>)
								((org.daisy.common.spi.ServiceWithProperties)service).spi_getProperties().entrySet()) {
							props.put(kv.getKey(), kv.getValue());
						}
#end
#if( ${component.proxy} )
#if( ${component.classLoader} )
						try {
							java.lang.reflect.Method m = delegate.getClass().getDeclaredMethod(
								"${reference.methodName}",
								${reference.service}.class#if (${reference.propertiesArgumentType}),
								${reference.propertiesArgumentType}.class#end

							);
							m.setAccessible(true);
							m.invoke(delegate, service#else
						delegate.${reference.methodName}(service#end#else
						${reference.methodName}(service#end
#if( ${reference.propertiesArgumentType} ), props#end
);
#if( ${component.classLoader} )
						} catch (NoSuchMethodException |
						         IllegalAccessException |
						         java.lang.reflect.InvocationTargetException e) {
							throw new RuntimeException(e);
						}
#end
						spi_log.trace("Bound ${reference.service} service: "
						              + service.getClass().getName() + "@"
						              + Integer.toHexString(System.identityHashCode(service)));
						refCount++;
						if (maxRef > 0 && refCount == maxRef)
							break;
					} catch (Throwable e) {
						spi_log.error("Error while binding ${reference.service} service", e);
					}
				}
			} catch (Throwable e) {
				spi_log.error("Error while binding ${reference.service} services", e);
			}
			if (refCount < minRef) {
				spi_log.warn("No ${reference.service} found");
				throw new RuntimeException("No ${reference.service} found");
			} else {
				spi_log.trace("Bound " + refCount + " ${reference.service} services.");
			}
		}
#end
#if( ${component.activate} )
		spi_log.trace("Activating ${component.className}");
#if( ${component.activate.propertiesArgumentType} )
		${component.activate.propertiesArgumentType.getName()} props = new ${component.activate.propertiesArgumentType.getName()}();
		props.put("component.name", "${component.name}");
#foreach($property in ${component.properties})
		props.put(${property.keyLiteral}, ${property.valueLiteral});
#end
#end
#if( ${component.classLoader} )
		try {
			java.lang.reflect.Method m = delegate.getClass().getDeclaredMethod(#if ( ${component.activate.propertiesArgumentType} )
				"${component.activate.methodName}",
				${component.activate.propertiesArgumentType}.class
			);
			m.setAccessible(true);
			m.invoke(
				delegate,
				props
			);
#else
"${component.activate.methodName}");
			m.setAccessible(true);
			m.invoke(delegate);
#end#else
#if( ${component.proxy} )
		delegate.${component.activate.methodName}(#else
		${component.activate.methodName}(#end
#if( ${component.activate.propertiesArgumentType} )props#end
);
#end
#if( ${component.classLoader} )
		} catch (NoSuchMethodException |
		         IllegalAccessException  e) {
			throw new RuntimeException(e);
		} catch (java.lang.reflect.InvocationTargetException e) {
			if (e.getCause() instanceof org.daisy.common.spi.ActivationException)
				throw (org.daisy.common.spi.ActivationException)e.getCause();
			else
				throw new RuntimeException(e);
		}
#end
#end
	}
#if( ${component.deactivate} )
	
	@Override
	protected void finalize() throws Throwable {
		spi_deactivate();
		super.finalize();
	}
#end
	
	public void spi_deactivate() {
#if( ${component.deactivate} )
		if (!spi_deactivated) {
			spi_log.trace("Deactivating ${component.className}");
			try {
#if( ${component.classLoader} )
				try {
					java.lang.reflect.Method m = delegate.getClass().getDeclaredMethod("${component.deactivate.methodName}");
					m.setAccessible(true);
					m.invoke(delegate);
				} catch (NoSuchMethodException |
				         IllegalAccessException |
				         java.lang.reflect.InvocationTargetException e) {
					throw new RuntimeException(e);
				}
#else
				#if( ${component.proxy} )delegate.#end
${component.deactivate.methodName}();
#end
			} catch (Throwable e) {
				spi_log.error("Caught exception while deactivating ${component.className}", e);
			} finally {
				spi_deactivated = true;
			}
		}
#end
	}
	
	public java.util.Map spi_getProperties() {
		return spi_props;
	}
#if( ${component.proxy} )
#foreach($method in ${component.serviceMethods})

	@Override
	public ${method.returnType} ${method.name}(#if (${method.argumentTypes.size()} > 0)

#foreach($arg in ${method.argumentTypes})
		$arg arg${foreach.count}#if( $foreach.hasNext ),
#end
#end

	#end)#if (${method.thrownTypes.size()} > 0) throws #foreach($thrown in ${method.thrownTypes})$thrown#if( $foreach.hasNext )

	       , #end
#end
#end {
		#if( ${component.classLoader} )try {
			#end
#if( ${method.returnType} != 'void' )
#if( ${component.classLoader} )
return (${method.returnType})#else
return #end#end
#if( ${component.classLoader} )
delegate.getClass().getMethod(#if (${method.argumentTypes.size()} > 0)

				"${method.name}"#foreach($arg in ${method.argumentTypes}),
				${arg.replaceAll("<.+>$", "")}.class#end

			#else
"${method.name}"#end
).invoke(
				delegate#if (${method.argumentTypes.size()} > 0),#end#else
delegate.${method.name}(#end
#if (${method.argumentTypes.size()} > 0)

#foreach($arg in ${method.argumentTypes})
			#if( ${component.classLoader} )	#end
arg${foreach.count}#if( $foreach.hasNext ),
#end
#end

		#if( ${component.classLoader} )	#end#else#if (${component.classLoader})

			#end#end);
#if( ${component.classLoader} )
		} catch (NoSuchMethodException |
		         IllegalAccessException e) {
			throw new RuntimeException(e);
		} catch (java.lang.reflect.InvocationTargetException e) {
#if (${method.thrownTypes.size()} > 0)
			Throwable cause = e.getCause();
#foreach($thrown in ${method.thrownTypes})
			if (cause instanceof $thrown)
				throw ($thrown)cause;
#end
#end
			throw new RuntimeException(e);
		} 
#end
	}
#end

	@Override
	public String toString() {
		return delegate.toString();
	}

	@Override
	public int hashCode() {
		return delegate.hashCode();
	}

	@Override
	public boolean equals(Object o) {
		if (this == o)
			return true;
		return delegate.equals(o);
	}
#end
}
